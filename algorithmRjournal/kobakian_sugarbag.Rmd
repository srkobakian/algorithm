---
title: An Algorithm For Spatial Mapping Using a Hexagon Tilegram, With Application to Australian Maps
author:
  - name: Stephanie Kobakian
    affiliation: Queensland University of Technology
    email:  stephanie.kobakian@monash.edu
  - name: Dianne Cook
    affiliation: Monash University
    email:  dicook@monash.edu
bibliography: RJreferences.bib
link-citations: true
fig_caption: yes
abstract: >
  This algorithm creates a hexagon to represent each of the spatial polygons provided. It allocates these hexagon in a manner that preserves the spatial relationship of the areas. It showcases spatial distributions, by emphasising the small geographical regions that are often difficult to locate on large geographic maps. Spatial distributions have been presented on alternative representations of geography for many years. In modern times, interactivity and animation have begun to play a larger role, as alternative representations have been popularised by online news sites, and atlas websites with a focus on public consumption. Applications are increasingly widespread, especially in the areas of disease mapping, and election results.
output:
  rticles::rjournal_article:
    includes:
      in_header: preamble.tex
editor_options: 
  chunk_output_type: console
---


```{r cache=TRUE, echo=FALSE, message=FALSE, warning=FALSE, comment = FALSE}
library(knitcitations)
library(RefManageR)
knitr::opts_chunk$set(echo=FALSE, 
                      message=FALSE, 
                      warning=FALSE, 
                      kfigr.link=TRUE, 
                      kfigr.prefix=TRUE, 
                      cache=TRUE, 
                      fig.cap=TRUE, comment = FALSE)
 
options("citation_format" = "pandoc")
BibOptions(check.entries = FALSE, style = "markdown", bib.style = "alphabetic", cite.style = 'alphabetic')
```

## Introduction

<!-- Motivation to map -->

Choropleths are current practice for presenting geographical data on a map, as they highlight the geographic patterns in geospatially related statistics [@SAMGIS].
The land on the map space is divided into separate areas, these boundaries are usually administrative, such as states or counties. The areas are filled with colour to represent the value of the statistic for the area [@EI].

<!-- urbanisation -->
Australian residents are increasingly congregating around major cities, the vast rural areas are often sparsely populated in comparison to the urban centres. 
In Australia, government bodies such as the Australian Bureau of Statistics, and the Australian Electoral Commission hold the responsibility for the division of areas.
These boundaries are adjusted as the population increases. 
The division of the population into approximately equal population areas results in dramatically different square meterage of the geographic areas. 
This results in an unequal visualisation of the statistic in each area, this can allow misrepresentation of the spatial distributions of human related statistics in geographic maps. 

<!-- solutions -->
A solution to this visualisation problem begins with the geography. Cartograms apply a transformation to the geographic boundaries based on the value of the statistic of interest. These displays result in a distortion of the map space to represent differences in the statistic across the areas [@ACCAC]. 
These displays rely on the statistic of interest to determine the layout.
Australian population statistics often result in a cartogram that fails to preserve a recognisable display due to the difference in size of metropolitan and rural areas, a common feature of British Colonies [@ACTUC].
Contiguous cartograms change the shape of an area, preserving neighbouring relationships. Non-contiguous cartograms maintain the geographic shape of each area, but lose the connection to neighbours.
Population cartograms use either of these methods with population as the statistic of interest [@GOINO].

Alternative maps shift the focus from land area and shape, to the value of the statistics in a group of areas.
Alternative mapping methods allow increased understanding of the spatial distribution of a variable across the population, by fairly representing each administrative area. This acknowledges that the amount of residents can be different despite best efforts to normalise the areas using boundary shifts, but recognises that each area is equally important.

Tilegrams are an extension of Rectangular cartograms [@ORC] and Dorling cartograms [@ACTUC], using one simple shape to represnt each area. This allows preservation of spatial relationships and decreases the emphasis from the amount of geographic area. These maps focus on the relationship between neighbours attempting to preserve connections, and disregard the unique shapes of the administrative boundaries.

The \CRANpkg{sugarbag} package provides a new method to implement hexagon tilegrams. 
Extending the tilegram to Australian applications required preserving the spatial relationships. It emphasises the capital cities as population hubs, and recognises the distances between locations of populations distributed across the large rural areas. 


# Algorithm

This solution operates on a set of \CRANpkg{sf} [@sf] polygons.

There are four tasks to create a hexagon tilegram.
These steps can be executed by the main function, `create_hexmap`, or can be implemented separately for more flexibility.

 1. Create the set of centroids to allocate
 2. Create the grid of hexagons to use
 3. Allocate each centroid to an available hexagon
 4. Transform the data for plotting


There are parameters used in the process that can be provided, if they are not, they will be automatically derived.

### Install sugarbag package

```{r libraries, message=FALSE, warning=FALSE, comment = FALSE}
# To install sugarbag:
# devtools::install_github("srkobakian/sugarbag")
library(sugarbag)
library(tidyverse)
```

### Parameters

The `create_hexmap` function requires several parameters, if they are not provided, the information will be derived from the simple features (\CRANpkg{sf}) set of shapes used. If users already have a grid and set of centroids they may choose to only use the `allocate` function.

*The following must be provided to `create_hexmap`:*
```{r table_necessary, echo = FALSE}
knitr::kable(tibble::tibble(parameter = c('shp', 
  'sf_id',
  'focal_points'),
  description = c(
    'an sf object containing the polygon information', 
    'name of a column that distinguishes unique areas',
    'a data frame of reference locations used to allocate hexagons'
    )), format = "latex")
```


### Tasmania example

The polygon set of Local Government Areas (sa2) of Tasmania in 2016 is provided with the \CRANpkg{sugarbag} package as `tas_sa2`. 
A single column of the data set must be used to identify the unique areas. 
In this case, the unique sa2 codes associated with each sa2 have been used.

The longitude and latitude centre of the capital cities of Australia are used to  allocate areas around the closest capital city, as this example uses only the areas in the state of Tasmania, Hobart will be the common focal point.

```{r capital_cities}
data(capital_cities)
```


**The following parameters will be determined within `create_hexmap` if they are not provided. They are created throughout the following example:**

```{r parameters, echo = FALSE}
knitr::kable(tibble(parameter = c('buffer_dist', 'hex_size',  'hex_filter', 'width'),
  description = c('a float value for distance in degrees to extend beyond the geometry provided',
    'a float value in degrees for the diameter of the hexagons', 'amount of hexagons around centroid to consider for allocation',
    'the angle used to filter the grid points around a centroid')), format = "latex")
```



## Create the set of centroid points

When utilising individual `sugarbag` functions, we recommend the following approach:
Begin with a set of polygons. The set should be provided as an `sf` object, this is a data frame containing a `geometry` column. ^[The `read_shape` function can assist in creating this object.] We will use the Statistical Areas of Tasmania, at Level 2, downloaded from the Australian Bureau of Statistics. 


The centroids can be derived from the set of polygons:
```{r cents, message=FALSE, warning=FALSE, comment = FALSE}
centroids <- create_centroids(shp_sf = tas_sa2, sf_id = "SA2_NAME16")
```

```{r derive_centroids, echo = FALSE}
## Use the create_centroids function to find polygon centroids:
## Join to data for each area
centroids <- left_join(centroids,
  sf::st_drop_geometry(tas_sa2), by = "SA2_NAME16")
```

```{r end_cents, fig.cap="Local Government Areas and derived centroids.", fig.height=2.5, fig.width = 5, echo = FALSE}
fort_sa2 <- fortify_sfc(tas_sa2)

polys <- ggplot() + 
  geom_polygon(aes(x = long, y = lat, group = interaction(SA2_NAME16, polygon)), data = fort_sa2, fill = "grey", size = 0.2, colour = "lightgrey") +theme_void() + coord_equal()

cents <- ggplot() + 
  geom_polygon(aes(x = long, y = lat, group = interaction(SA2_NAME16, polygon)), data = fort_sa2, fill = "grey", size = 0.2, colour = "lightgrey") + geom_point(aes(x=longitude, y = latitude), data = centroids) + theme_void() + coord_equal()

gridExtra::grid.arrange(polys, cents, nrow = 1)
```

## Create the hexagon grid points

A tilegram allocates areas to a tellesated set of tiles.
The grid is created to ensure tessellation with other previously allocated points.

The grid of possible hexagon centroids can be made using the `create_grid` function.
The grid creation requires several steps.
It uses the centroids, the hexagon size and the buffer distance.

```{r}
grid <- create_grid(centroids = centroids, hex_size = 0.2, buffer_dist = 1.2)
```

```{r bbox, echo = FALSE}
## create the bounding box from the set of polygon centroids:
bbox <- tibble::tibble(min = c(min(centroids$longitude, na.rm = TRUE), min(centroids$latitude, na.rm = TRUE)),
        max = c(max(centroids$longitude, na.rm = TRUE), max(centroids$latitude, na.rm = TRUE)))

hex_size = 0.2
 
# default size calculation:
#(bbox$max[1] - bbox$min[1])/(bbox$max[2] - bbox$min[2]) / 5
  
buffer_dist <- max((bbox$max[1] - bbox$min[1]), (bbox$max[2] - bbox$min[2]))*0.3
```


### Step 1: Inital grid

Creating the grid involves using the centroids provided to find the minimum and maximum, longitude and latitude centroid values.
The buffer distance is used to extend the equally spaced rows and columns from the minimum longitude (latitude) minus the buffer distance, up to the maximum longitude (latitude) plus the buffer distance.
The set of longitude columns, and latitude rows  are created to define hexagons which are the size specified by `hex_size`.
An individual hexagon location is created from all intersections of the longitude columns and latitude rows.

```{r grid, echo = FALSE}
grid <- tibble::as_tibble(
  expand.grid(
    hex_long = seq(bbox$min[1] - buffer_dist, # minimum
      bbox$max[1] + buffer_dist, # maximum
      hex_size), # distance between hexagons
    hex_lat = seq(bbox$min[2] - buffer_dist, # minimum
      bbox$max[2] + buffer_dist, # maximum
      hex_size))) # distance between hexagons

grid1 <- ggplot() + geom_polygon(aes(x = long, y = lat, group = interaction(SA2_NAME16, polygon)), data = fort_sa2, fill = "grey", size = 0.2, colour = "lightgrey") + geom_point(aes(x=longitude, y = latitude), data= centroids, colour = "#b2df8a") + theme_void() + coord_equal() +
  geom_point(aes(x = hex_long, y = hex_lat), colour = "#1f78b4", data = grid, size = 0.75) 
```

A square grid will not facilitate tessellated hexagons. Every second latitude row of points must be shifted right by half of the hexagon size.

```{r shift, echo = FALSE}
# Find every second latitude
shift_lat <- grid %>% dplyr::select(hex_lat) %>%
    dplyr::distinct() %>%
    dplyr::filter(dplyr::row_number() %% 2 == 1) %>% unlist()

# Shift the longitude of every second latitude to the right to make hex structure
grid <- grid %>%
    dplyr::mutate(hex_long = ifelse(hex_lat %in% shift_lat, hex_long,
        hex_long + (hex_size / 2))) %>%
    dplyr::mutate(id=1:NROW(.)) %>%
    dplyr::mutate(assigned=FALSE)

grid2 <- ggplot() + geom_polygon(aes(x = long, y = lat, group = interaction(SA2_NAME16, polygon)), data = fort_sa2, fill = "grey", size = 0.2, colour = "lightgrey") + geom_point(aes(x=longitude, y = latitude), data = centroids, colour = "#b2df8a") + theme_void() + coord_equal() +
  geom_point(aes(x = hex_long, y = hex_lat), colour = "#1f78b4", data = grid, size = 0.75) 

full_grid <- grid <- grid %>%
    mutate(hex_long_int = dense_rank(hex_long)-1,
        hex_lat_int = dense_rank(hex_lat)-1)
```

```{r, fig.cap="Grid points to create a tilegram.", fig.height=2.5, fig.width = 5, echo = FALSE}
gridExtra::grid.arrange(grid1, grid2, nrow = 1)
```

### Step 2: Rolling windows

Not all of the grid points will be used, especially if islands result in a large grid space.
To filter the grid for appropriate points for allocation,
the `create_buffer` function is called from `create_grid`.
It finds the grid points needed to best capture the set of centroids.

```{r fort_grid, echo = FALSE}
fort_grid <- fortify_hexagon(data = grid, sf_id = "id", hex_size = 0.2)

```

```{r windows, echo = FALSE}
nlong <- length(unique(grid$hex_long))
nlat <- length(unique(grid$hex_lat))

centroids <- centroids %>%
  mutate(long_int = round((longitude-min(grid$hex_long))/(max(grid$hex_long)-min(grid$hex_long))*nlong, 0),
          lat_int = round((latitude-min(grid$hex_lat))/(max(grid$hex_lat)-min(grid$hex_lat))*nlat, 0))
```

The rows and columns are divided into 20 groups.
The amount of rows in each latitude group and the amount of columns in each longitude group are then used as the width of rolling windows. This will tailor the available grid points to the most likely to be used point.
It also helps reduce amount of time taken, as it decreases the amount of points considered.

```{r sizes, echo = FALSE}
# Amount of lats and longs in each group
lat_size = round(nlat/20,0)
long_size = round(nlong/20,0)
```

The first rolling window function finds the minimum and maximum centroid values for the sliding groups of longitude columns and the groups of latitude rows.

```{r rolling_windows, echo = FALSE}
 # make a list of groups, manual sliding windows
    nlat_list <- purrr::map2(seq(1:nlat), lat_size + seq(1:nlat), c)
    nlong_list <- purrr::map2(seq(1:nlong), long_size + seq(1:nlong), c)


    lat_window <- function(x, cents = centroids, maximum = nlat){
        max_int = min(x[2],maximum)

        cents_in <- filter(cents, between(lat_int, x[1], max_int))
        return(cents_in)
    }

    long_window <- function(x, cents = centroids, maximum = nlong){
        max_int = x[2]
        while (max_int > maximum){
            max_int = max_int - 1
        }

        cents_in <- filter(cents, between(long_int, x[1], max_int))
        return(cents_in)
    }
    

    # LATITUDE ROWS FILTER
    # amount of latitude in sliding window
    lat_windows <- purrr::map(.x = nlat_list, .f = lat_window)
    # LONGITUDE COLS FILTER
    long_windows <- purrr::map(.x = nlong_list, .f = long_window)

    # find the min and max longitude for each latitude
    range_rows <- purrr::map_dfr(.x = lat_windows,
        .f = function(x) {x %>%
                dplyr::summarise(
                    long_min = ifelse(purrr::is_empty(long_int), NA, min(x$long_int)),
                    long_max = ifelse(purrr::is_empty(long_int), NA, max(x$long_int))
                )}
    )
    
    # find the min and max longitude for each latitude
    range_cols <- purrr::map_dfr(.x = long_windows, .f = function(x) { x %>%
            dplyr::summarise(
                lat_min = ifelse(purrr::is_empty(lat_int), NA, min(x$lat_int)),
                lat_max = ifelse(purrr::is_empty(lat_int), NA, max(x$lat_int))
            )}
    )
```

The second rolling window function finds the average of the rolling centroid values minimum and maximum, for the longitude columns and latitude rows.

```{r rolling_ave, echo = FALSE}
 # smooth the minimums
    av_range_rows <- purrr::map_dfr(.x = nlat_list, .f = function(x, rows = range_rows) {
        rows[x[1]:min(x[2], NROW(rows)),] %>%
            dplyr::summarise(mean_long_min = mean(long_min, na.rm=T), mean_long_max = mean(long_max, na.rm=T))
    }) %>%
        bind_cols(lat_id = c(seq(1:nlat) + lat_size), .)

    
    # smooth the minimums
    av_range_cols <- purrr::map_dfr(.x = nlong_list, .f = function(x, cols = range_cols) {
        cols[x[1]:min(x[2], NROW(cols)),] %>%
            dplyr::summarise(mean_lat_min = mean(lat_min, na.rm=T), mean_lat_max = mean(lat_max, na.rm=T))
    }) %>%
        bind_cols(long_id = c(seq(1:nlong) + long_size + round(long_size/2)), .)

```
<!--
Figure of rolling window construction
-->
### Step 3: Filtering the grid

Only the grid points between the rolling average of the minimum and maximum centroid values are kept, for each row and column of the grid.

```{r filter_grid, echo = FALSE, fig.height = 2.5, fig.width = 2.5}
    # APPLY A BUFFER
    # change buffer to amount of hexagons (ints) either side
    hex_buffer <- floor(buffer_dist/hex_size)

    grid <- grid %>%
        left_join(., av_range_rows, by = c("hex_lat_int" = "lat_id")) %>%
        left_join(., av_range_cols, by = c("hex_long_int" = "long_id")) %>%
        rowwise() %>%
        mutate(long_buffer = ifelse(between(hex_long_int,mean_long_min - hex_buffer,
            mean_long_max + hex_buffer), "in", "out")) %>%
        mutate(lat_buffer = ifelse(between(hex_lat_int,mean_lat_min - hex_buffer,
            mean_lat_max + hex_buffer), "in", "out")) %>%
        filter(lat_buffer =="in" | long_buffer == "in")

    
ggplot() + geom_polygon(aes(x = long, y = lat, group = interaction(SA2_NAME16, polygon)), data = fort_sa2, fill = "grey", size = 0.2, colour = "lightgrey")  +
  geom_polygon(aes(x = long, y = lat, group = id), data = fort_grid, fill = NA, colour = "#a6cee3") +
  geom_point(aes(x=longitude, y = latitude), data = centroids, colour = "#b2df8a", fill = "red") + theme_void() + coord_equal() +
  geom_point(aes(x = hex_long, y = hex_lat), colour = "#1f78b4", data = grid, size = 0.75)
```


## Centroid to focal point distance 

```{r split_centroids, echo = FALSE}
# Split the centroid data set
centroids <- centroids %>% 
  nest(data = c(longitude, latitude)) %>% 
  mutate(closest = map(data, closest_focal_point, focal_points = capital_cities %>% filter(points == "Hobart"))) %>% 
  unnest(c(data, closest)) %>% 
  arrange(focal_distance)
```

For each polygon centroid in the set, the distance to each of the focal points provided is recorded. The closest focal point name, the distance to the polygon centroid, and the angle from focal point to polygon centroid will be added to the polygon's row, in the polygon data set. To minimise time taken for this step, only Tasmania's capital city Hobart has been provided.

The distance between the polygon centroid and it's closest focal point data set is used to order the data set for allocation. The points are arranged in ascending order, from the centroid closest to any of the focal points, to the furthest.

## Allocate each centroid to a hexagon grid point

The distance around a centroid to consider for possible hexagon locations is determined by the hex_filter. It multiplies the amount given by hex_filter, by the size of the hexagons to find the distance. 


```{r centroids, eval = FALSE, fig.height = 2.5, fig.width = 2.5}
hexmap_allocation <- allocate(
  centroids = centroids %>% select(SA2_NAME16, longitude, latitude),
  sf_id = "SA2_NAME16",
  hex_grid = grid,
  hex_size = 0.2, # same size used in create_grid
  hex_filter = 10,
  width = 35,
  focal_points = capital_cities,
  verbose = TRUE
)
```


Allocation of all centroids can now take place using the set of polygon centroids and the hexagon map grid. 
For each polygon centroid, only the hexagon grid points that have not yet been used can be considered.
Allocate each centroid, beginning with the closest centroid to a focal point.
This will preserve spatial relationship with the capital, as the inner areas will be allowed closest to the capital, and the areas that are further will be accommodated after.

```{r arrange, echo = FALSE}
s_centroids <- centroids %>% arrange(focal_distance)

s_centroids <- split(s_centroids, s_centroids[["focal_distance"]])
        
# Set up allocation data frame
centroid_allocation <- NULL
```

The filter parameter is used to subset possible grid points to only those surrounding the polygon centroid within the filter distance, smaller distance will increase speed, but can decrease accuracy.

```{r orig_dist, echo = FALSE}
hex_filter = 10
width = 35
# keep value to reset expanded distances
expand_dist <- hex_filter
```

The following example considers one of the Local Government Areas. 
These steps are repeated for each polygon.

### Step 1: Filter the grid for unassigned hexagon points

Keep only the available hexagon points, this will prevent multiple areas being allocated to the same hexagon.

```{r available_points, echo = FALSE}
# filter for only the available hex grid points
hex_grid <- grid %>% filter(!assigned)
```

### Step 2: Filter the grid points for those closest to the centroid

This will allow only the closest points, that are not assigned, to be considered.

```{r close_points, echo = FALSE}
filter_dist <- hex_filter*hex_size

# filter grid for avaiable points
centroid1 <- centroids %>% head(1)

flong <- centroid1$longitude
flat <- centroid1$latitude

hex_grid <- hex_grid %>% ungroup() %>%
        filter(flat - filter_dist < hex_lat & hex_lat < flat + filter_dist) %>%
        filter(flong - filter_dist < hex_long & hex_long < flong + filter_dist)

```

Create a box of possible hexagon locations around the centroid. The bottom of the box will not be square as the buffer has already removed unnecessary points from over the ocean.

```{r plot_buffer, echo = FALSE}
buff1 <- ggplot()+
   geom_polygon(aes(x = long, y = lat, group = interaction(SA2_NAME16, polygon)), data = fort_sa2, fill = "grey", size = 0.2, colour = "lightgrey") + 
  geom_point(aes(x=longitude, y = latitude), data = centroids, colour = "#b2df8a", fill = "red")  + 
  geom_point(aes(x=longitude, y = latitude), data = centroid1, colour = "orange") + theme_void() +
    geom_polygon(aes(x = long, y = lat, group = id), data = fort_grid, fill = NA, colour = "#a6cee3") +  geom_point(aes(x = hex_long, y = hex_lat), colour = "#1f78b4", data = hex_grid, size = 1) +
  theme_void() + coord_equal() 
```


The algorithm removes the outer corners of the square, creating a circle of points, by only keeping points within a certain radius around the original centroid location.

```{r buffer_circle, echo = FALSE}
    hex_grid <- hex_grid %>%
        rowwise %>%
        mutate(
        hex_lat_c = hex_lat - flat,
        hex_long_c = hex_long - flong) %>%
        mutate(hyp = ((hex_lat_c^2) + (hex_long_c^2))^(1/2))


        f_angle <- centroid1 %>%
            mutate(atan = atan2(latitude-focal_latitude,longitude-focal_longitude),
                angle = (atan*180/pi),
                pangle = ifelse(angle<0, angle +360, angle)) %>% pull()


        hex_grid <- hex_grid %>%
            # create circle of radius: hex_filter
            filter(hyp < filter_dist) %>%
            mutate(
                # geosphere takes a long time
                angle = f_angle,
                angle_plus = (angle + width)%%360,
                angle_minus = (angle - width)%%360,
                atan = atan2(hex_lat_c, hex_long_c),
                hex_angle = (atan*180/pi),
                hex_angle = ifelse(hex_angle<0, hex_angle +360, hex_angle))

```


```{r plot_circle, echo = FALSE}
buff2 <- ggplot() + 
   geom_polygon(aes(x = long, y = lat, group = interaction(SA2_NAME16, polygon)), data = fort_sa2, fill = "grey", size = 0.2, colour = "lightgrey") + 
  geom_point(aes(x=longitude, y = latitude), data = centroids, colour = "#b2df8a", fill = "red")  + 
  geom_point(aes(x=longitude, y = latitude), data = centroid1, colour = "orange") + theme_void() +
    geom_polygon(aes(x = long, y = lat, group = id), data = fort_grid, fill = NA, colour = "#a6cee3") +  geom_point(aes(x = hex_long, y = hex_lat), colour = "#1f78b4", data = hex_grid, size = 1) +
  theme_void() + coord_equal() 

```


```{r buffers, echo = FALSE, fig.height=2.5, fig.width = 5}
gridExtra::grid.arrange(buff1, buff2, nrow=1)
```


The width parameter is now used. Of the remaining points, a slice is taken. This uses the angle from the closest capital city, to the current centroid. If it is not the closest to the capital there may have been points available that were taken by closer centroids. This allows the spatial relationship to be preserved, even when it gets allocated to a hexagon that is further from the city centre. This angle begins at 30 degrees by default, and may increase if necessary.

If no available hexagon grid point is found within the original filter distance and angle, the distance is expanded, only when a maximum distance is reached will the angle expand to accommodate more possible grid points.  

The allocation is returned and combined with the data relating to each polygon.

```{r buffer_slice, echo = FALSE}

# Filter for angle within circle
  if (hex_grid$angle_minus[1] < hex_grid$angle_plus[1]) {
     hex_grid <- hex_grid %>%
         # create slice of 60 degrees from centroid
         filter(angle_minus < hex_angle & hex_angle < angle_plus)
  } else {
     hex_grid <- hex_grid %>%
         # create slice of 60 degrees from centroid
         filter(hex_angle < angle_plus | angle_minus > hex_angle)
  }

buff3 <- ggplot() + geom_polygon(aes(x = long, y = lat, group = interaction(SA2_NAME16, polygon)), data = fort_sa2, fill = "grey", size = 0.2, colour = "lightgrey") +  
   geom_polygon(aes(x = long, y = lat, group = interaction(SA2_NAME16, polygon)), data = fort_sa2, fill = "grey", size = 0.2, colour = "lightgrey") + 
  geom_point(aes(x=longitude, y = latitude), data = centroids, colour = "#b2df8a", fill = "red")  + 
  geom_point(aes(x=focal_longitude, y = focal_latitude), data = centroid1, colour = "red") +
  geom_point(aes(x=longitude, y = latitude), data = centroid1, colour = "orange") +
    geom_polygon(aes(x = long, y = lat, group = id), data = fort_grid, fill = NA, colour = "#a6cee3") + 
  geom_point(aes(x = hex_long, y = hex_lat), colour = "#1f78b4", data = hex_grid, size = 1) +
  theme_void() + coord_equal() 
    
    
```

This area was the very closest to the Hobart central point ( coloured pink) provided in the capital cities data set, it gets a hexagon point (coloured blue) extremely close to it's centroid (coloured green).


```{r choose_point, echo = FALSE}
# Choose first available point
cent <- centroid1 %>% dplyr::rename(focal_point = points, focal_dist = focal_distance, focal_angle = angle)

# Filter should give one hex point
hex <- hex_grid %>% 
  ungroup %>% 
  filter(hyp == min(hyp)) %>%
  select(hex_long, hex_lat, hex_id = id)

# Update grid to show this centroid as assigned
hex_grid[which(hex_grid$id == hex$hex_id),]$assigned <- TRUE

# Add to table of allocated centroids
centroid_allocation <- bind_rows(centroid_allocation, dplyr::bind_cols(cent, hex)) %>% as_tibble()

```


```{r allocated, echo = FALSE}
hex_points_df <- centroid_allocation %>% 
  fortify_hexagon(hex_size = hex_size,
  sf_id = "SA2_NAME16")

buff4 <- ggplot() + geom_polygon(aes(x = long, y = lat, group = interaction(SA2_NAME16, polygon)), data = fort_sa2, fill = "grey", size = 0.2, colour = "lightgrey") +  
    geom_point(aes(x=longitude, y = latitude), data = centroids, colour = "#b2df8a", fill = "red")  + 
  geom_point(aes(x=focal_longitude, y = focal_latitude), data = centroid1, colour = "red") +
  geom_point(aes(x=longitude, y = latitude), data = centroid1, colour = "orange") +
    geom_polygon(aes(x = long, y = lat, group = id), data = fort_grid, fill = NA, colour = "#a6cee3") + 
  geom_point(aes(x = hex_long, y = hex_lat), colour = "#1f78b4", data = hex_grid, size = 1) +
  theme_void() + coord_equal() 
```

```{r buffs, fig.height = 2.5, fig.width = 5, echo = FALSE}
gridExtra::grid.arrange(buff3, buff4 , nrow=1)
```

The following code creates a map for all the Local Government Areas in Tasmania:

```{r full_hexmapcode, echo = TRUE, warning = FALSE}
# Create centroids set
centroids <- create_centroids(tas_sa2, "SA2_NAME16")
# Create hexagon location grid
grid <- create_grid(centroids = centroids,
    hex_size = 0.2,
    buffer_dist = 1.2)
# Allocate polygon centroids to hexagon grid points
hex_allocated <- allocate(
  centroids = centroids,
  hex_grid = grid,
  sf_id = "SA2_NAME16",
  # same column used in create_centroids
  hex_size = 0.2,
  # same size used in create_grid
  hex_filter = 10,
  focal_points = capital_cities %>% filter(points == "Hobart"),
  width = 35,
  verbose = FALSE
)
```

# Transform the data for plotting

To plot polygons using \CRANpkg{ggplot} the \CRANpkg{sf} object can be transformed to a set of indidivual points that can be joined as a polygon.

```{r create_plot_final, fig.height=2.5, fig.width = 5, message = FALSE, warning = FALSE}
h1 <- hex_allocated %>%
  fortify_hexagon(hex_size = 0.2, 
  sf_id = "SA2_NAME16") %>% 
  left_join(., tas_sa2)
```

```{r plot_final, echo = FALSE, fig.height=2.5, fig.width = 5, message = FALSE, warning = FALSE}
p1 <- fortify_sfc(tas_sa2)
end_hex <- ggplot() +
  geom_polygon(data = p1, aes(x=long, lat, group = interaction(SA2_NAME16, polygon)), fill = "grey", size = 0.2, colour = "lightgrey") +
  geom_polygon(aes(x=long, y = lat, group = SA2_NAME16), data = h1, colour = "white", fill = "#b2df8a") + theme_void() + coord_equal()
  

gridExtra::grid.arrange(cents, end_hex, nrow = 1)
```

## Summary

It is possible to use alternative maps to communicate spatial distributions.
Current methods do not always work for Australia due to the large gaps between densely populated capital cities.

## Code 

This map algorithm is found in the `sugarbag` package, currently available on github: https://github.com/srkobakian/sugarbag

@R

\bibliography{algorithmbib}
