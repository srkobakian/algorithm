---
title: An Algorithm For Spatial Mapping Using a Hexagon Tilegram, With Application to Australian Maps
author:
  - name: Stephanie Kobakian
    affiliation: Queensland Univeristy of Technology
    email:  stephanie.kobakian@monash.edu
  - name: Dianne Cook
    affiliation: Monash University
    email:  dicook@monash.edu
abstract: >
  This algorithm creates a hexagon to represent each of the spatial polygons provided. It allocates these hexagon in a manner that preserves the spatial relationship of the areas. It showcases spatial distributions, by emphasising the small geograhical regions that are often diffcult to locate on large geographic maps.
output:
  rticles::rjournal_article:
    includes:
      in_header: preamble.tex
---


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE,
  cache = FALSE,
  message = FALSE,
  warning = FALSE,
  fig.height = 3, fig.width = 3)
```

## Introduction

Spatial distrbutions have utilised alternative representations of geography for many years. In modern times interactivity and animation have begun to play a larger role, as alternative representations have been popularised by online news sites, with a focus on public consumption. Applications are increasingly widespread, especially in the areas of disease mapping, and election results.

## Motivation

Spatial distributions of people and human related statistics can be misrepresented in geographic maps. Populations congregate around major cities and vertical living is increasingly common. Population statistics often requires dividing people into smaller, measureable areas. Government bodies such as the Australian Bureau of Statistics, or intentionally segregated organisations, like the Australian Electoral Comission hold the responsibility of the division. Australia is an example of strong urbanisation, the rural areas are often sparsely populated in comparison to the urban centres. To divide the population equally, the square meterage of the geographic areas differ dramatically in size.

Alternative mapping methods allow increased understanding of the spatial distribution of a variable across the population. Alternative maps allow the focus to be placed on the distribution of the statistics between the groups of areas.

Extremely small geographic areas are lost on large geographic maps, small inner areas of Sydney or Melbourne are not easily compared at a high level.
Cartograms place importance on the statistic of interest, allowing distorted map space on the display to represent differences in the statistic. These maps rely on the statistic of interest to determine the layout, and for Australia, often fail to preserve a recognisable view.
Tilegrams allow preservation of spatial relationships as they decrease the emphasis on the amount of geograhic area considered to be interesting. These maps focus on the relationship between neighbours, in considering aggregated statistics of heterogeneous regions.

Our case is an extension of these concepts. Extending the tilegram to Australian applications required preserving the spatial relationships. It emphasises the capital cities as population hubs, and recognises the populations distributed across the large rural areas. 


# Algorithm

Our solution operates on a set of polygons.
There are parameters used in the process that may be provided, or will be automatically derived.
All necessary functions are exported, with a main function `create_hexmap` used to step through these automatically.

## Parameters

The `create_hexmap` function requires several parameters, if they are not provided, the information will be derived from the polygon set used. 

**The following must be provided to `create_hexmap`:**
```{r table_necessary}
knitr::kable(tibble::tibble(parameter = c('shp', 
  'shp_path',
  'sf_id',
  'capital_cities'),
  description = c('an Rdata object containing the polygon information', 'character string location of the shape file that contains the polygon information', 'name of a unique column that distinguishes areas',
    'a data frame of reference locations used to allocate hexagons'
    )), format = "latex")

```

```{r libraries}
library(tidyverse)
# To install sugarbag:
# devtools::install_github("srkobakian/sugarbag")
library(sugarbag)
```

The polygon set of Local Government Areas in Tasmania in 2016 is stored in the sugarbag package data as `tas_lga`. 
A single column of the data set must be used as a unique identifier of areas. In this case, the unique LGA codes associated with each LGA have been used, their names could have also been used.

```{r id}
sf_id <- "LGA_CODE16"
```

The centre of the population hubs are used to distribute areas around the closest captial city.

```{r data}
data(capital_cities)
```


**The following parameters will be determined within `create_hexmap` if not provided. They are created throughout the following example:**

```{r}
knitr::kable(tibble(parameter = c('buffer_dist', 'hex_size',  'hex_filter', 'width'),
  description = c('a float value for distance in degrees to extend beyond the - geometry provided',
    'a float value in degrees for the diameter of the hexagons', 'amount of hexagons around centroid to consider for allocation',
    'the angle used to filter the grid points around a centroid')), format = "latex")
```



When utilising individual `sugarbag` functions, we recommend the following approach:

## Polygon Information

Begin with a set of polygons. The set should be provided as an `sf` object, this is a data frame containing a `geometry` column. The `read_shape` function can assist in creating this object. We will use the Loca Goverment Areas of Tasmania, sourced from the Australian Bureau of Statistics. 

```{r}
# Create a suitable data set for plotting
fort_lga <- fortify_sfc(tas_lga)

# Include area variable
area_var <- fort_lga %>% 
  distinct(LGA_CODE16, .keep_all = TRUE) %>% 
  select(LGA_CODE16, AREASQKM16)
```


```{r centroids}
## Use the create_centroids function to find polygon centroids:
centroids <- create_centroids(shp_sf = tas_lga, sf_id = sf_id) %>%
  left_join(., select(area_var, LGA_CODE16, AREASQKM16), by = "LGA_CODE16")
```


```{r, fig.cap="lga Local Government Areas and derived centroids."}
end_cents <- ggplot() + 
  geom_polygon(aes(x = long, y = lat, group = group), data = fort_lga, fill = "grey", colour = "white") + geom_point(aes(x=longitude, y = latitude), data= centroids) + theme_void() + coord_equal()
end_cents

#ggplot() + geom_histogram(aes(x = log(AREASQKM16), fill = log(AREASQKM16)), data= centroids, bins = 20) 
```


## Hexagon grid

Each new hexagon will need to tesselate, a grid is created to ensure a close point is found, that will allow all areas to tesselate, this is inspired by tilegrams. The grid of possible hexagon centroids can be made using the `create_grid` function. The grid creation takes several steps. It requires the centroids, the hexagon size and the buffer distance.

```{r bbox}
## create the bounding box from the set of polygon centroids:
bbox <- tibble::tibble(min = c(min(centroids$longitude, na.rm = TRUE), min(centroids$latitude, na.rm = TRUE)),
        max = c(max(centroids$longitude, na.rm = TRUE), max(centroids$latitude, na.rm = TRUE)))

hex_size <- 0.2
 
# default size calculation:
#(bbox$max[1] - bbox$min[1])/(bbox$max[2] - bbox$min[2]) / 5
  
buffer_dist <- max((bbox$max[1] - bbox$min[1]), (bbox$max[2] - bbox$min[2]))*0.3
```


### Step 1: Expand the grid

One sequence is created for longitude columns, and another for latitude rows.

The sequences begin at the minimum longitude or latitude, minus the buffer distance.
Equally spaced intervals the size of the hexagons are created up to the maximum longitude or latitude, plus the buffer distance.

An individual point is created from all intersections of the longitude columns and latitude row sequences.

```{r grid}
grid <- tibble::as_tibble(
  expand.grid(
    hex_long = seq(bbox$min[1] - buffer_dist, # minimum
      bbox$max[1] + buffer_dist, # maximum
      hex_size), # distance between hexagons
    hex_lat = seq(bbox$min[2] - buffer_dist, # minimum
      bbox$max[2] + buffer_dist, # maximum
      hex_size))) # distance between hexagons
```

```{r plot_grid}
ggplot() + geom_polygon(aes(x = long, y = lat, group = group), data = fort_lga, fill = "grey", colour = "white") + geom_point(aes(x=longitude, y = latitude), data= centroids, colour = "#b2df8a") + theme_void() + coord_equal() +
  geom_point(aes(x = hex_long, y = hex_lat), colour = "#1f78b4", data = grid, size = 0.75) 
```

A square grid will not facilitate tessellated hexagons. Every second latitude row of points will be shifted right by half of the hexagon size.

```{r shift}
# Find every second latitude
shift_lat <- grid %>% dplyr::select(hex_lat) %>%
    dplyr::distinct() %>%
    dplyr::filter(dplyr::row_number() %% 2 == 1) %>% unlist()

# Shift the longitude of every second latitude to the right to make hex structure
grid <- grid %>%
    dplyr::mutate(hex_long = ifelse(hex_lat %in% shift_lat, hex_long,
        hex_long + (hex_size / 2))) %>%
    dplyr::mutate(id=1:NROW(.)) %>%
    dplyr::mutate(assigned=FALSE)
```

```{r plot_shift}
ggplot() + geom_polygon(aes(x = long, y = lat, group = group), data = fort_lga, fill = "grey", colour = "white") + geom_point(aes(x=longitude, y = latitude),data= centroids, fill = "#b2df8a") + theme_void() + coord_equal() +
  geom_point(aes(x = hex_long, y = hex_lat), colour = "#1f78b4", data = grid, size = 0.75) 
```

Each point is now given an ID.

```{r grid_id}
full_grid <- grid <- grid %>%
    mutate(hex_long_int = dense_rank(hex_long)-1,
        hex_lat_int = dense_rank(hex_lat)-1)
```


### Step 2: Rolling windows

Not all of the grid points will be used, especially if islands impact the overall space covered.
To filter the grid for appropriate points for allocation,
the `create_buffer` function is called from `create_grid`.
It finds the amount of columns and rows needed to best capture the set of centroids.

```{r}
nlong <- length(unique(grid$hex_long))
nlat <- length(unique(grid$hex_lat))

centroids <- centroids %>%
  mutate(long_int = round((longitude-min(grid$hex_long))/(max(grid$hex_long)-min(grid$hex_long))*nlong, 0),
          lat_int = round((latitude-min(grid$hex_lat))/(max(grid$hex_lat)-min(grid$hex_lat))*nlat, 0))
```

The rows and columns are divided into 20 groups. The amount of rows in each latitude group and the amount of columns in each longitude group are then used as the width of manual rolling windows. This will tailor the available points to the areas most likely to be used. It helps reduce amount of time taken.

```{r echo = FALSE}
# Amount of lats and longs in each group
lat_size = round(nlat/20,0)
long_size = round(nlong/20,0)
```

The specific rows and columns in the rolling windows are defined.The first rolling window function finds the minimum and maximum centroid values for the sliding groups of longitude columns and the groups of latitude rows.


```{r echo = FALSE}
 # make a list of groups, manual sliding windows
    nlat_list <- purrr::map2(seq(1:nlat), lat_size + seq(1:nlat), c)
    nlong_list <- purrr::map2(seq(1:nlong), long_size + seq(1:nlong), c)


    lat_window <- function(x, cents = centroids, maximum = nlat){
        max_int = min(x[2],maximum)

        cents_in <- filter(cents, between(lat_int, x[1], max_int))
        return(cents_in)
    }

    long_window <- function(x, cents = centroids, maximum = nlong){
        max_int = x[2]
        while (max_int > maximum){
            max_int = max_int - 1
        }

        cents_in <- filter(cents, between(long_int, x[1], max_int))
        return(cents_in)
    }
    

    # LATITUDE ROWS FILTER
    # amount of latitude in sliding window
    lat_windows <- purrr::map(.x = nlat_list, .f = lat_window)

    # find the min and max longitude for each latitude
    range_rows <- purrr::map_dfr(.x = lat_windows,
        .f = function(x) {x %>%
                dplyr::summarise(
                    long_min = ifelse(purrr::is_empty(long_int), NA, min(x$long_int)),
                    long_max = ifelse(purrr::is_empty(long_int), NA, max(x$long_int))
                )}
    )
```



The second rolling window function finds the average of the rolling minimum and rolling maximum centroid values, for the longitude columns and latitude rows.

```{r echo = FALSE}
 # smooth the minimums
    av_range_rows <- purrr::map_dfr(.x = nlat_list, .f = function(x, rows = range_rows) {
        rows[x[1]:min(x[2], NROW(rows)),] %>%
            dplyr::summarise(mean_long_min = mean(long_min, na.rm=T), mean_long_max = mean(long_max, na.rm=T))
    }) %>%
        bind_cols(lat_id = c(seq(1:nlat) +lat_size), .)

    # LONGITUDE COLS FILTER
    long_windows <- purrr::map(.x = nlong_list, .f = long_window, centroids, nlong)

    # find the min and max longitude for each latitude
    range_cols <- purrr::map_dfr(.x = long_windows, .f = function(x) { x %>%
            dplyr::summarise(
                lat_min = ifelse(purrr::is_empty(lat_int), NA, min(x$lat_int)),
                lat_max = ifelse(purrr::is_empty(lat_int), NA, max(x$lat_int))
            )}
    )

    # smooth the minimums
    av_range_cols <- purrr::map_dfr(.x = nlong_list, .f = function(x, cols = range_cols) {
        cols[x[1]:min(x[2], NROW(cols)),] %>%
            dplyr::summarise(mean_lat_min = mean(lat_min, na.rm=T), mean_lat_max = mean(lat_max, na.rm=T))
    }) %>%
        bind_cols(long_id = c(seq(1:nlong) + round(long_size/2)), .)

```

<!--
Figure of rolling window construction
-->

### Step 3: Filtering the grid

Only the grid points between the rolling average of the minimum and maximum centroid values are kept, for each row and column of the grid.

```{r echo = FALSE}
    # APPLY A BUFFER
    # change buffer to amount of hexagons (ints) either side
    hex_buffer <- floor(buffer_dist/hex_size)

    grid <- grid %>%
        left_join(., av_range_rows, by = c("hex_lat_int" = "lat_id")) %>%
        left_join(., av_range_cols, by = c("hex_long_int" = "long_id")) %>%
        rowwise() %>%
        mutate(long_buffer = ifelse(between(hex_long_int,mean_long_min - hex_buffer,
            mean_long_max + hex_buffer), "in", "out")) %>%
        mutate(lat_buffer = ifelse(between(hex_lat_int,mean_lat_min - hex_buffer,
            mean_lat_max + hex_buffer), "in", "out")) %>%
        filter(lat_buffer =="in" | long_buffer == "in")

```


```{r plot_buffer}
ggplot() + geom_polygon(aes(x = long, y = lat, group = group), data = fort_lga, fill = "grey", colour = "white") + geom_point(aes(x=longitude, y = latitude),data= centroids, fill = "#b2df8a", fill = "red") + theme_void() + coord_equal() +
  geom_point(aes(x = hex_long, y = hex_lat), colour = "#a6cee3", data = full_grid, size = 0.25) +
  geom_point(aes(x = hex_long, y = hex_lat), colour = "#1f78b4", data = grid, size = 0.75)
```


## Centroid to focal point distance 

```{r split_centroids}
# Split the centroid data set
centroids <- centroids %>% 
  nest(longitude, latitude) %>% 
  mutate(closest = map(data, closest_focal_point, focal_points = capital_cities %>% filter(points == "Hobart"))) %>% 
  unnest(data, closest) %>% 
  arrange(focal_distance)
```

For each polygon centroid in the set, the distance to each of the focal points provided is recorded. The closest focal point name, the distance to the polygon centroid, and the angle from focal point to polygon centroid will be added to the polygon's row, in the polygon data set. To minimise time taken for this step, only Tasmania's capital city Hobart has been provided.

The distance between the polygon centroid and it's closest focal point data set is used to order the data set for allocation. The points are arranged in ascending order, from the centroid closest to any of the focal points, to the furthest.

## Allocation of centroids

The distance around a centroid to consider for possible hexagon locations is determined by the hex_filter. It multiplies the amount given by hex_filter, by the size of the hexagons to find the distance. 

```{r}
## Consider hexagon points up to a certain distance from centroid
hex_filter <- 10
```


```{r}
width = 15
```


```{r, eval = FALSE}
hexmap_allocation <- allocate(centroids = centroids,
        hex_grid = grid,
        hex_size = hex_size,
        hex_filter = hex_filter,
        width = width,
        focal_points = capital_cities,
        verbose = TRUE,
        id = sf_id)
```


Allocation of all centroids can now take place using the set of polygon centroids and the hexagon map grid. 
For each polygon centroid, only the hexagon grid points that have not yet been used can be considered.
Allocate each centroid, beginning with the closest centroid to a focal point.
This will preserve spatial relationship with the capital, as the inner areas will be allowed closest to the captial, and the areas that are further will be accomodated after.

```{r arrange}
s_centroids <- centroids %>% arrange(focal_distance)

s_centroids <- split(s_centroids, s_centroids[["focal_distance"]])
        
# Set up allocation data frame
centroid_allocation <- NULL
```

The filter parameter is used to subset possible grid points to only those surrounding the polygon centroid within the filter distance, smaller distance will increase speed, but can decrease accuracy.

```{r orig_dist}
# keep value to reset expanded distances
expand_dist <- hex_filter
```

The following example considers one of the Local Government Areas. 
These steps are repeated for each polygon.

### Step 1: Filter the grid for unassigned hexagon points

Keep only the available hexagon points, this will prevent multiple areas being allocated to the same hexagon.

```{r available_points}
# filter for only the available hex grid points
hex_grid <- grid %>% filter(!assigned)
```

### Step 2: Filter the grid points for those closest to the centroid

This will allow only the closest points, that are not assigned, to be considered.

```{r close_points}
# filter grid for avaiable points
centroid1 <- centroids %>% head(1)

flong <- centroid1$longitude
flat <- centroid1$latitude

hex_grid <- hex_grid %>% ungroup() %>%
        filter(flat - buffer_dist < hex_lat & hex_lat < flat + buffer_dist) %>%
        filter(flong - buffer_dist < hex_long & hex_long < flong + buffer_dist)

```

Create a box filter

```{r, echo = FALSE}
ggplot() + geom_polygon(aes(x = long, y = lat, group = group), data = fort_lga, fill = "grey", colour = "white") + geom_point(aes(x=longitude, y = latitude),data= centroid1, fill = "red") + theme_void() + coord_equal() +
  geom_point(aes(x = hex_long, y = hex_lat), colour = "#a6cee3", data = grid, size = 0.25) +
  geom_point(aes(x = hex_long, y = hex_lat), colour = "#1f78b4", data = hex_grid, size = 0.75)

```


Create circle filter

```{r}
    hex_grid <- hex_grid %>%
        rowwise %>%
        mutate(
        hex_lat_c = hex_lat - flat,
        hex_long_c = hex_long - flong) %>%
        mutate(hyp = ((hex_lat_c^2) + (hex_long_c^2))^(1/2))


        f_angle <- centroid1 %>%
            mutate(atan = atan2(latitude-latitude1,longitude-longitude1),
                angle = (atan*180/pi),
                pangle = ifelse(angle<0, angle +360, angle)) %>% pull()


        hex_grid <- hex_grid %>%
            # create circle of radius: hex_filter
            filter(hyp < hex_filter) %>%
            mutate(
                # geosphere takes a long time
                angle = f_angle,
                angle_plus = (angle + width)%%360,
                angle_minus = (angle - width)%%360,
                atan = atan2(hex_lat_c, hex_long_c),
                hex_angle = (atan*180/pi),
                hex_angle = ifelse(hex_angle<0, hex_angle +360, hex_angle))

```


```{r, echo = FALSE}
ggplot() + geom_polygon(aes(x = long, y = lat, group = group), data = fort_lga, fill = "grey", colour = "white") + geom_point(aes(x=longitude, y = latitude),data= centroid1, fill = "red") + theme_void() + coord_equal() +
  geom_point(aes(x = hex_long, y = hex_lat), colour = "#a6cee3", data = grid, size = 0.25) +
  geom_point(aes(x = hex_long, y = hex_lat), colour = "#1f78b4", data = hex_grid, size = 0.75)
```


Filter for angle within circle, relates hexagon location to focal point, Sydney.

```{r}
# Filter for angle within circle

        if (hex_grid$angle_minus[1] < hex_grid$angle_plus[1]) {
            hex_grid <- hex_grid %>%
                # create slice of 60 degrees from centroid
                filter(angle_minus < hex_angle & hex_angle < angle_plus)
        } else {
            hex_grid <- hex_grid %>%
                # create slice of 60 degrees from centroid
                filter(hex_angle < angle_plus | angle_minus > hex_angle)
        }

```





```{r}

ggplot() + geom_polygon(aes(x = long, y = lat, group = group), data = fort_lga, fill = "grey", colour = "white") + geom_point(aes(x=longitude, y = latitude),data= centroid1, fill = "red") + theme_void() + coord_equal() +
  geom_point(aes(x = hex_long, y = hex_lat), colour = "#a6cee3", data = grid, size = 0.25) +
  geom_point(aes(x = hex_long, y = hex_lat), colour = "#1f78b4", data = hex_grid, size = 0.75)

```



```{r}

# Choose first available point
        cent <- centroid1 %>% dplyr::rename(focal_point = points, focal_dist = focal_distance, focal_angle = angle)

        # Filter should give one hex point
        hex <- hex_grid %>% 
          ungroup %>% 
          filter(hyp == min(hyp)) %>%
          select(hex_long, hex_lat, hex_id = id)

        #update grid to show this centroid as assigned
        hex_grid[which(hex_grid$id == hex$hex_id),]$assigned <- TRUE

        centroid_allocation <- bind_rows(centroid_allocation, dplyr::bind_cols(cent, hex)) %>% as_tibble()

```


Using the angle between each polygon centroid, and it's the closest focal point, the subset of points is filtered again.
Of these possible points, only those within a specific amount of degrees plus and minus a specific angle range are kept. This angle begins at 30 degrees by default, and may increase if necessary.

If no available hexagon grid point is found within the original filter distance and angle, the distance is expanded, only when a maximum distance is reached will the angle expand to accommodate more possible grid points.  

The allocation is returned and combined with the data relating to each polygon.

```{r}
hex_points_df <- centroid_allocation %>% 
  fortify_hexagon(hex_size = hex_size)
```

```{r}
ggplot(hex_points_df) + 
  geom_polygon(aes(x = long, y = lat, group = LGA_CODE16)) +
  coord_equal() +
  geom_point(aes(x = hex_long, y = hex_lat), colour = "#a6cee3", data = grid, size = 0.25) +
  geom_point(aes(x = hex_long, y = hex_lat), colour = "#1f78b4", data = hex_grid, size = 0.75)
```


```{r fullhexmap}
# Create centroids set
centroids <- create_centroids(tas_lga, "LGA_CODE16")
# Create hexagon location grid
grid <- create_grid(centroids = centroids, hex_size = 0.25, buffer_dist = 1.2)
# Allocate polygon centroids to hexagon grid points
hex_allocated <- allocate(centroids = centroids,
hex_grid = grid,
sf_id = "LGA_CODE16",
hex_size = 0.25, # same size used in create_grid
hex_filter = 10,
focal_points = capital_cities,
width = 30, verbose = FALSE) # same column used in create_centroids
```


```{r}
h1 <- hex_allocated %>%
  fortify_hexagon(hex_size = 0.25) %>% 
  left_join(., tas_lga)

p1 <- fortify_sfc(tas_lga)

end_hex <- ggplot() +
  geom_polygon(data = p1, aes(x=long, lat, group = group), alpha = 0.1) +
  geom_polygon(data = h1, aes(x=long, lat, group = LGA_CODE16)) + theme_void() + coord_equal()

gridExtra::grid.arrange(end_hex, end_cents)
```

## Applications of algorithm

<!--
Is  your  solution  always  working?  
Can  you  prove it? 
How does it work? 
-->

Examples of Melbourne, lga, Australia
At different levels, distance from original centroids, change in area

LGA of all Australia
SA2 for lga

<!--
Is your analysis about worst case or average case? 
What kind of theoretical and analytical support can you give for your proposed scheme/solution? 
-->

\bibliography{algorithmbib}
