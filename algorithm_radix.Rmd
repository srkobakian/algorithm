---
title: "An algorithm for a spatial mapping using a hexagon tilegram, with application to Australia disease maps"

author:
  - name: Stephanie Kobakian
    url: https://github.com/srkobakian
    affiliation: Queensland University of Technology
date: "`r Sys.Date()`"
output: radix::radix_article
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE)
```

# Abstract

<!--
problem has been studied
what is the goal of the thesis/paper
brief statement on existing solutions and their drawbacks
major  contributions  of  the  thesis
State  briefly  assumptions  and  limitations. 
The  abstract  should  also  include  major idea(s)
the type (e.g. performance, complexity) and result of analysis done
-->

KEYWORDS: 

# Introduction

Representing the globe in 2D space has presented issues for many years. Methods have been established to visualise geographical space.
We present a solution for alternate visualisations when the intention is to represent the spatial distribution.


## Motivation
<!--
Problem   statement   (precise   definition   and   importance);   
avoid   very   technical definitions  and  statements, give  good  intuition for your involved definitions or facts. 
-->

- Spatial distributions are not well presented when areas differ in size.
- We want to understand the distribution among population
- We can benefit from making the focus the distribution, not the geography

<!--
Existing  solutions  and  their  criticism  (limit  only  to  those  directly  relevant  to  the  contribution of the thesis; give a motivation for doing research on the topic); 
-->

- Presenting spatial distributions
- Extremely small areas are lost not easily compared at a high level
- Choropleths; unequal space on the display, difficult to represent Australia
- Cartograms; strong distortions misrepresent Australia

<!--
With different characteristics or properties:

-->

- Unusual population settlement and dispersion over the geographical space: Australia
Dense south east, sparse central and west


- Applying alternative maps that allow for dense population areas when cities that are population dense are close together



## Background
<!--
basic facts needed to tune the reader to the thesis or paper
-->

- Choropleth methods are accurate geographically.
- Cartogram alternative map has been used historically.
- Spatial relationships are preserved.

<!--
all  known  results  relevant  to  the  problem  stated,  
whether  or  not  they  are  used  in  proposed  contributions
-->

<!--
Discuss  advantages  and  drawbacks  of  known  solutions  that  are  relevant  to  your  problem, 
discuss  the  relevance of each reviewed item to your topic and your solutions. 
-->

<!--
For  every  discussed  reference,  it  is  very  important  to  relate  them  to  your  problem  and  contribution  in  one  of  several  ways:  
it  does  not  exactly  solve  the  same  problem,
it  solves  the  same  problem  but  makes  different  assumptions  about  the  system, 
it  has  some  limitations  that you  do  not  have, 
it  makes  the  same  assumptions  but  does  not  work  well  under  certain  
conditions  and  scenarios  for  which  you  have  better  solutions,  or, 
if  none  of  these  is  true,  you are   considering   it   as   valid   competitor,   and   will   try   to   defeat   it   in   your   analytical   or 

experimental  comparisons.  
-->
## Proposed Solution

<!--
Contributions (proposed solutions; why they are expected to be better; essence of the idea(s) used in proposed solutions); 
What the algorithm is trying to do:
-->

- Like Dorling, same shape will be used.
Like tilegram, tessellation using equally sized shapes.

- Allocate each geographic area to a map space of consistent tessellated shape

which is different from existing algorithms:
- contiguous, keeps exact neighbours, no recognisable shape
- non contiguous, keeps shape, can lose neighbours


<!--
Why the reader should believe that it is correct or reasonable.
-->
- Clear to see spatial distribution, 
_ Should keep neighbours relationships intact as geographic neighbours will have similar values

<!--
If it is supposed to be “better”, what is meant by better.
-->
Easier to read distribution at a distance, see a much larger area, general relationship at a glance

<!--
Conditions, assumptions and limitations of the research done; 
-->
Works well for America, states are almost homogeneous 
Works well for England, London is the biggest issue, pushing out rural areas does not disturb population dense areas.

<!--
Analysis  (theoretical,  experimental,  simulations,  implementations, done  in  thesis;  under what conditions and scenarios is your solution best?  
-->

Our solution considers multiple population dense areas.

Allows dispersion to be increased when needed, and distance from origin to be considered


The Dorling maps in [@TVSSS] give examples of displacing central geographically small, population dense areas.
This inspired the concept of this algorithm. 



# Algorithm

The algorithm operates on a set of polygons.
There are parameters needed that may be provided, or will be automatically derived.
All necessary functions are exported, with a main function `create_hexmap` used to step through automatically.

## Parameters

The `create_hexmap` functions requires several parameters. If not provided the information may be derived from the polygon set used. 

**The following must be provided to `create_hexmap`:**

The set of polygons to be made into a hexagon map:
`shp: a shape file`

The location of a set of polygons to be made into a hexagon map:
`shp_path: character string location of shape file`

A column of unique names or id values for each area
`sf_id: name of a unique column that distinguishes areas`

A data frame of reference points to determine the order of allocation
`focal_points a data frame of reference locations when allocating hexagons, capital cities of Australia are provided as capital_cities`

```{r}
library(tidyverse)
library(sugaRbag)

shp_path <- "data/lga_2011.rda"
sf_id <- "LGA_CODE11"
focal_points <- sugaRbag::capital_cities
```


**The following will be determined within `create_hexmap` if not provided, but must be created for the following example:**

- `projstring	a string to indicate the projection and epsg`
- `epsg	the four character string to indicate the CRS`
- `buffer_dist: a float value for distance in degrees to extend beyond the - geometry provided`
- `hex_size	a float value in degrees for the diameter of the hexagons`
- `filter_dist amount of hexagons around centroid to consider for allocation`
- `width the angle used to filter the grid points around a centroid`

These parameters will be created when they are needed in the example:

```{r}
width <- 30 # arbitrary angle width
```


<!--
needed later:

- filter distance: *the amount of hexagons around each centroid to consider for allocation, by default this is 10 hexagons*
-->


When utilising individual functions, we recommend the following approach:

## Polygon Information

The collection of polygons should be considered first.
There are several ways of providing the set of polygons.
The following methods are available via the `read_shape` function.

- To utilise a shape file from a directory on your device, provide the file path for .shp file.
- The `st_read` function is applied internally to create the sf object.
- If the shape file is an .Rda file, it is loaded into the current environment.

Empty geometries are removed from the sf object, and the remaining polygons are projected to the Australian standard.

We will use the Local Government Areas of Hobart as an example:

```{r}
# Read in shape information
tas_shp <- read_shape(shp_path = shp_path)

# Convert to a simple features object
tas_lga <- sf::st_as_sf(tas_shp)

# Select only desired LGA areas, those from Tasmania.
tas_lga <- tas_shp %>% filter(STE_NAME11 == "Tasmania")
tas_lga[[sf_id]] <- droplevels(as.factor(tas_lga[[sf_id]]))

## Not necessary within `create_hexmap`:
## Derive projection information
crs_info <- sf::st_crs(tas_lga)
proj4string <- crs_info$proj4string
epsg <- crs_info$epsg

## For UTM as per shape file
projstring <- paste0("+init=epsg:", epsg, " ", proj4string, collapse = "")
## if long lat is preferred to UTM, and not in proj4string:
projstring <- "+init=epsg:3112 +proj=longlat +lat_1=-18 +lat_2=-36 +lat_0=0 +lon_0=134 +x_0=0 +y_0=0 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +no_defs"

tas_lga <- tas_lga %>%
    sf::st_transform(., crs = projstring)

## Use the create_centroids function to find polygon centroids:
centroids <- create_centroids(shp_sf = tas_lga, sf_id = sf_id, projstring = projstring, verbose = FALSE)
```


```{r, fig.cap="Tasmanian Local Government Areas and derived centroids."}
fort_tas <- fortify_sfc(tas_lga, projstring = projstring)
ggplot() + geom_polygon(aes(x = long, y = lat, group = group), data = fort_tas, fill = "green") + geom_point(aes(x=longitude, y = latitude),data= centroids)
```


## Hexagon grid

Create a grid of hexagon centroids using the `create_grid` function.

The grid creation takes several steps. It requires the centroids, the bounding box, the hexagon size and the buffer distance.

```{r}
## Not necessary within `create_hexmap`:
## create the bounding box from the set of polygon centroids:
bbox <- tibble::tibble(min = c(min(centroids$longitude), min(centroids$latitude)),
        max = c(max(centroids$longitude), max(centroids$latitude)))

hex_size <- (bbox$max[1] - bbox$min[1])/(bbox$max[2] - bbox$min[2]) / 10

buffer_dist <- max((bbox$max[1] - bbox$min[1]), (bbox$max[2] - bbox$min[2]))*0.3
```


### Step 1: Expand the grid
Two sequences are used, one for longitude and another for latitude.
The sequences begin at the minimum longitude or latitude, minus the buffer distance.
Equally spaced intervals, the size of the hexagons, are created up to the maximum longitude or latitude, plus the buffer distance.

An individual point is created from all combinations of longitude and latitude sequences.

```{r}
grid <- tibble::as.tibble(expand.grid(hex_long = seq(bbox$min[1] - buffer_dist,
    bbox$max[1] + buffer_dist,
    hex_size),
    hex_lat = seq(bbox$min[2] - buffer_dist,
        bbox$max[2] + buffer_dist,
        hex_size)))
```

This grid is square, which will not facilitate tessellated hexagons. 
Every second latitude (row) of points will be shifted right by half of the hexagon size.

```{r}
# Find every second latitude
shift_lat <- grid %>% dplyr::select(hex_lat) %>%
    dplyr::distinct() %>%
    dplyr::filter(dplyr::row_number() %% 2 == 1) %>% unlist()

# Shift the longitude of every second latitude to the right to make hex structure
grid <- grid %>%
    dplyr::mutate(hex_long = ifelse(hex_lat %in% shift_lat, hex_long,
        hex_long + (hex_size / 2))) %>%
    dplyr::mutate(id=1:NROW(.)) %>%
    dplyr::mutate(assigned=FALSE)
```

Each row and column is given an ID

```{r}
full_grid <- grid %>%
    mutate(hex_long_int = dense_rank(hex_long)-1,
        hex_lat_int = dense_rank(hex_lat)-1)
```

There are more points than necessary on this grid.

### Step 2: Rolling windows

To filter the grid for appropriate hexagons for allocation,
the `create_buffer` function is used.

```{r}
grid <- create_buffer(centroids, full_grid, hex_size, buffer_dist)
```

The rows and columns are divided into 20 groups. The amount of rows in each latitude group and the amount of columns in each longitude group are then used as the width of manual rolling windows.

The first rolling window function finds the minimum and maximum centroid values for the groups of longitude columns and the groups of latitude rows.

The second rolling window function finds the average of the rolling minimum and rolling maximum centroid values, for the longitude columns and latitude rows.

<!--
Figure of rolling window construction
-->

### Step 3: Filtering the grid
Only the grid points between the rolling average of the minimum and maximum centroid values are kept, for each row and column of the grid.

```{r}
ggplot() + geom_polygon(aes(x = long, y = lat, group = group), data = fort_tas, fill = "green") + geom_point(aes(x=longitude, y = latitude), colour = "red", data= centroids) +
  geom_point(aes(x = hex_long, y = hex_lat), colour = "black", data = full_grid, size = 0.5) +
  geom_point(aes(x = hex_long, y = hex_lat), colour = "grey", data = grid, size = 0.75)
```

<!--
Grid point figure
-->

## Centroid to focal point distance 

```{r}
# Split the centroid data set
centroids <- centroids %>% 
  nest(longitude, latitude) %>% 
  mutate(closest = map(data, closest_focal_point, focal_points = focal_points)) %>% 
  unnest(data, closest) %>% 
  arrange(focal_distance)
```

For each polygon centroid in the set. Find the distance to each of the focal points provided. The closest focal point name, the distance to the polygon centroid, and the angle from focal point to polygon centroid will be returned and added to the polygon data set in the polygon centroid row. 

The distance between the polygon centroid and it's closest focal point data set is used to arrange the data set for allocation. The points are arranged in ascending order, from the centroid closest to any of the focal points, to the furthest.

## Allocation of centroids

Define a distance around a centroid to consider for possible hexagon location.

```{r}
## Not necessary within `create_hexmap`:
## Consider hexagon points up to a certain distance from centroid

filter_dist <- (hex_size)*10
```

Allocate each centroid, beginning with the closest to a focal point, extending to the furthest. Will preserve spatial relationship.

```{r, eval = FALSE}
hexmap_allocation <- allocate(centroids = centroids,
        hex_grid = grid,
        hex_size = hex_size,
        filter_dist = filter_dist,
        width = width,
        focal_points = focal_points,
        verbose = TRUE,
        id = sf_id)
```


Allocation of all centroids can now take place using the set of polygon centroids and the hexagon map grid. 
For each polygon centroid, only the hexagon grid points that have not yet been used can be considered.

```{r}
s_centroids <- centroids %>% arrange(focal_distance)

s_centroids <- split(s_centroids, s_centroids[["focal_distance"]])
        
# Set up allocation data frame
centroid_allocation <- NULL
```

The filter distance parameter is used to subset possible grid points to only those surrounding the polygon centroid within the filter distance.

```{r}
# keep value to reset expanded distances
expand_dist <- filter_dist
```


The following example considers one of the Local Government Areas. 
These steps are repeated for each polygon.

### Step 1: Filter the grid for unassigned hexagon points

```{r}
# filter for only the available hex grid points
hex_grid <- grid %>% filter(!assigned)
```

### Step 2: Filter the grid points for those closest to the centroid
```{r}

# filter grid for avaiable points
centroid1 <- centroids %>% head(1)

flong <- centroid1$longitude
flat <- centroid1$latitude

hex_grid <- hex_grid %>% ungroup() %>%
        filter(flat - filter_dist < hex_lat & hex_lat < flat + filter_dist) %>%
        filter(flong - filter_dist < hex_long & hex_long < flong + filter_dist)

```

Create a box filter
```{r, echo = FALSE}
ggplot() + geom_polygon(aes(x = long, y = lat, group = group), data = fort_tas, fill = "green") + geom_point(aes(x=longitude, y = latitude), colour = "red", data= centroids[1,]) +
  geom_point(aes(x = hex_long, y = hex_lat), colour = "grey", data = hex_grid, size = 0.75) +
  geom_point(aes(x = hex_long, y = hex_lat), colour = "orange", data = hex_grid, size = 0.75)
```


```{r}
    grid <- grid %>%
        rowwise %>%
        mutate(
        hex_lat_c = hex_lat - flat,
        hex_long_c = hex_long - flong) %>%
        mutate(hyp = ((hex_lat_c^2) + (hex_long_c^2))^(1/2))

```

Create circle filter

```{r, echo = FALSE}
ggplot() + geom_polygon(aes(x = long, y = lat, group = group), data = fort_tas, fill = "green") + geom_point(aes(x=longitude, y = latitude), colour = "red", data= centroids[1,]) +
  geom_point(aes(x = hex_long, y = hex_lat), colour = "grey", data = hex_grid, size = 0.75) +
  geom_point(aes(x = hex_long, y = hex_lat), colour = "orange", data = hex_grid, size = 0.75)
```



```{r}

    # Filter for angle within circle
    if ("focal_distance" %in% colnames(centroid1)) {

        f_angle <- centroid1 %>%
            mutate(atan = atan2(latitude-latitude1,longitude-longitude1),
                angle = (atan*180/pi),
                pangle = ifelse(angle<0, angle +360, angle)) %>% pull()


        grid <- grid %>%
            # create circle of radius: filter_dist
            filter(hyp < filter_dist) %>%
            mutate(
                # geosphere takes a long time
                angle = f_angle,
                angle_plus = (angle + angle_width)%%360,
                angle_minus = (angle - angle_width)%%360,
                atan = atan2(hex_lat_c, hex_long_c),
                hex_angle = (atan*180/pi),
                hex_angle = ifelse(hex_angle<0, hex_angle +360, hex_angle))


        if (grid$angle_minus[1] < grid$angle_plus[1]) {
            grid <- grid %>%
                # create slice of 60 degrees from centroid
                filter(angle_minus < hex_angle & hex_angle < angle_plus)
        }
        else {
            grid <- grid %>%
                # create slice of 60 degrees from centroid
                filter(hex_angle < angle_plus | angle_minus > hex_angle)
        }

    }

```





```{r}
ggplot() + geom_polygon(aes(x = long, y = lat, group = group), data = fort_tas, fill = "green") + geom_point(aes(x=longitude, y = latitude), colour = "red", data= centroids[1,]) +
  geom_point(aes(x = hex_long, y = hex_lat), colour = "grey", data = hex_grid, size = 0.75) +
  geom_point(aes(x = hex_long, y = hex_lat), colour = "orange", data = hex_grid, size = 0.75)
```



```{r}

# Choose first available point
        cent <- centroid1 %>% dplyr::rename(focal_point = points, focal_dist = focal_distance, focal_angle = angle)

        # Filter should give one hex point
        hex <- hex_grid %>% 
          ungroup %>% 
          filter(hyp == min(hyp)) %>%
          select(hex_long, hex_lat, hex_id = id)

        #update grid to show this centroid as assigned
        hex_grid[which(hex_grid$id == hex$hex_id),]$assigned <- TRUE

        centroid_allocation <- bind_rows(centroid_allocation, dplyr::bind_cols(cent, hex)) %>% as.tibble()

```


Using the angle between each polygon centroid, and it's the closest focal point, the subset of points is filtered again.
Of these possible points, only those within a specific amount of degrees plus and minus a specific angle range are kept. This angle begins at 30 degrees by default, and may increase if necessary.

<!--
figure of angle growing to show allocation of hexagons
-->

If no available hexagon grid point is found within the original filter distance and angle, the distance is expanded, only when a maximum distance is reached will the angle expand to accommodate more possible grid points.  

The allocation is returned and combined with the data relating to each polygon.

<!--
Prose code:  Number each step, never break a loop over steps,
use sub numbering for parts of each step, and
include explanatory text.
Literate code:  The algorithm is introduced gradually,
intermingled with discussion of underlying ideas.
-->

## Applications of algorithm

<!--
Is  your  solution  always  working?  
Can  you  prove it? 
How does it work? 
-->

Examples of Melbourne, Tasmania, Australia
At different levels, distance from original centroids, change in area

LGA of all Australia
SA2 for Queensland

<!--
Is your analysis about worst case or average case? 
What kind of theoretical and analytical support can you give for your proposed scheme/solution? 
-->


# Evaluation

<!--
The  performance  of  your  solution  can  be  compared  with  existing  solutions,  if  any  exists 
under  same  or  similar  assumptions,  analytically  and/or  by  doing  a  simulation.

Find examples of measures of cartogram effectiveness


-->

Measure changes to areas:
Each hexagon area in the set of $npolys$ is standardised to 1 unit.
Where 1 unit is the area of a hexagon of the designated size.

$area_{h_i} = 1$

$area_h = 1 * npolys$

$y_i$ denotes the statistic of interest for polygon i, where i = 1,...,npolygs
$x_i$ denotes the spatial area for polygon i, where i = 1,...,npolys

Areal Statistic Distortion is the change in the areal distribution of the set of polygons.
Difference between space taken by polygons and space taken by hexagons, with respect to the desired statistic. Setting the desired statistic to area gives the change in map space used to represent the polygons. 

The average when considering area used to display:

$A = \sum_{i=1}^{npolys}y_ix_i/ \sum_{i=1}^{npolys}x_i$

$H = \sum_{i=1}^{npolys}y_i/npolys$

Using $w_i = x_i/\sum_{i=1}^{npolys}x_i$

$\sqrt{ 1/npolys\sum_{i=1}^{npolys}(y_i - \bar y)^2 w_i }$

Considering only a local area distortion: 
Where the subset used contains only neighbours within a certain distance of the polygon centroid

Where $\bar y_d$ is the average of the polygon statistics considering only the polygons where the distance between polygon centroid x_i and polygon centroid x_p is less than d:

$d(x_ix_p) < d$


$\sqrt{ 1/npolys\sum_{i=1}^{npolys}(y_i - \bar y_d)^2 w_i }$

Old neighbours over new neighbours?
<!--
Apply methods of evaluation used elsewhere
Nusrat, Alam and Kobourov:
- Statistical accuracy: how well do the modified areas
represent the corresponding statistic shown (e.g.,
population or GDP). This is measured in terms of
“cartographic error.”
- Geographical accuracy: how much do the modified
shapes resemble the original geographic shapes and
how well preserved are their relative positions.
- Topological accuracy: how well does the topology (as
measured by adjacent regions) of the cartogram
match that of the original map.
-->

# Summary

<!--
What did you achieve with this research? 
What are the drawbacks of your solution(s)? 
What kind  of  future  work  can  be  done? 
Do  you  have  some  ideas  that  you  intend  to  study  further? 
The  ownership  of  some  other  possible  solutions,  not  fully  explored,  or  subject  of  your  
forthcoming  different  article,  can  be  protected  by  outlining  them  briefly  in  the  conclusion  
section, sometimes with reference to upcoming article. 
-->

# Discussion


\pagebreak

# Reference List

<div id="refs"></div>